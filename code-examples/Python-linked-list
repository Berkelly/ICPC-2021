#Work in Progress, has not been tested yet
#Node class and some functions in DoublyLinkedList class taken from Rosetta Code: http://www.rosettacode.org/wiki/Doubly-linked_list/Element_definition#Python
#Insert function taken from Rosetta Code: http://www.rosettacode.org/wiki/Doubly-linked_list/Element_insertion#Python
#Minor modifications made by Berkelly Gonzalez

class Node(object):
     def __init__(self, data, prev = None, nextN = None):  # the = means that argument is optional and default value after the equals sign will be used if one isn't suppiled #
         self.prev = prev
         self.nextN = nextN
         self.data = data
         
     def __str__(self):
         return str(self.data)
     
     def __repr__(self):
         return repr(self.data)
         
class DoublyLinkedList(object):
     def __init__(self, head, tail):
          self.head = head
          self.tail = tail
          if head is not None:
               self.head.nextN = tail
          if tail is not None:
               self.tail.prev = head
     
     def __str__(self):
         for node in self.iter_forward(self.head):
             node.__str__()
     
     def __repr__(self):
         for node in self.iter_forward(self.head):
             node.__repr__()
     
     def iter_forward(self, node):
         c = node
         while c is not None:
             yield c  # geeksforgeeks.org/use-yield-keyword-instead-return-keyword-python/#
             c = c.next
         return c
     
     def iter_backward(self, node):
         c = node
         while c is not None: 
             yield c
             c = c.prev
         return c
     
     def insert(self, newNode, node=None):
         if node is None:  # inserts at BEGINNING of list by default#
             newNode.nextN = self.head
             if self.head is not None:
               self.head.prev = newNode
             self.head = newNode
         else:  # inserts AFTER specified node #
             newNode.nextN = node.next
             newNode.prev = node
             if newNode.nextN is None:
                 self.tail = newNode
             else:
                 node.nextN.prev = newNode
             node.nextN = newNode
     
     def delete(self, node):
         if node.nextN is None and node.prev is None:
             self.head = None
             self.tail = None
         elif node.nextN is None:
             self.tail = node.prev
             node.prev.nextN = None
         elif node.prev is None:
             self.head = node.next
             node.nextN.prev = None
         else:
             node.prev.nextN = node.next
             node.nextN.prev = node.prev
         
        
     def find(data, node=self.head):
         c = node
         while c.data != data and c != None:
             yield c
             c = c.nextN
         if c != None:
             return c
         else:
             return None
         
         
    
