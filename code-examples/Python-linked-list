#Written by Berkelly Gonzalez as a reference for SBCC's ICPC 2021 teams
#Please read the comments, known limitations of the code denoted with "Caution!"
#Other limitations may still exist, don't forget to test edge cases before submitting

def find(data, node):
    c = node
    while c is not None and c.data != data:
        c = c.nextN
    return c  # Only returns the first node with matching data, stick it in a loop to search entire list #


def iter_forward(node): 
    c = node
    while c is not None:
        yield c  # geeksforgeeks.org/use-yield-keyword-instead-return-keyword-python/#
        c = c.nextN


def iter_backward(node):
    c = node
    while c is not None:
        yield c  # geeksforgeeks.org/use-yield-keyword-instead-return-keyword-python/#
        c = c.prev


class Node(object):
    def __init__(self, data, prev=None, nextN=None):  # the = means that argument has a default value and is optional #
        # Caution! If the value of data is None it will break the find function #
        self.prev = prev
        self.nextN = nextN
        self.data = data

    def __str__(self):  # if you pass a node to print() or str(), you'll get the node data as a string #
        # ex: node.data = ICPC -> print(node) will print ICPC, str(node) will return the string 'ICPC' #
        return str(self.data)


class DoublyLinkedList(object):
    def __init__(self, head=None):
        # Caution! initializing a new list using a node from another list will break the old list #
        self.head = head
        self.tail = head  # Any list that isn't empty should always have both a tail and a head #
        self.length = 0

        if self.head is not None:
            self.length += 1
            self.head.prev = None
            self.head.nextN = None

    def insert_after(self, newNode, node):  # Caution! doesn't allow inserting into an empty list #
        newNode.nextN = node.nextN
        newNode.prev = node

        if node is self.tail:
            self.tail = newNode
        else:
            node.nextN.prev = newNode

        node.nextN = newNode
        self.length += 1
        return newNode  # returns the node that was inserted #

    def insert_before(self, newNode, node):  # Caution! doesn't allow inserting into an empty list #
        newNode.nextN = node
        newNode.prev = node.prev

        if node is self.head:
            self.head = newNode
        else:
            node.prev.nextN = newNode

        node.prev = newNode
        self.length += 1
        return newNode  # returns the node that was inserted #

    def insert_head(self, newNode):  # can be used to insert into an empty list #
        if self.head is None:
            newNode.nextN = None
            self.tail = newNode
        else:
            self.head.prev = newNode
            newNode.nextN = self.head

        newNode.prev = None
        self.head = newNode
        self.length += 1
        return self.head # returns the head of the list #

    def insert_tail(self, newNode):  # can be used to insert into an empty list #
        if self.tail is None:
            newNode.prev = None
            self.head = newNode
        else:
            self.tail.nextN = newNode
            newNode.prev = self.tail

        newNode.next = None
        self.tail = newNode
        self.length += 1
        return self.tail # returns the tail of the list #

    def delete_node(self, node):
        if node is self.tail:
            self.tail = node.prev
        else:
            node.nextN.prev = node.prev

        if node is self.head:
            self.head = node.nextN
        else:
            node.prev.nextN = node.nextN

        c = node.nextN
        node.nextN = None # this and next line are likely not necessary, can remove if you really want to #
        node.prev = None
        self.length -= 1
        return c  # returns node after the one that was deleted, or none if tail was deleted #

    def delete_list(self, node1, node2=None):  # not inclusive, won't delete node2, will delete tail if node2 is not specified #
        c = node1
        while c is not None and c is not node2:
            d = c
            c = c.nextN
            self.delete_node(d)
        return c  # Will return either None or node2 when finished #
